---
marp: true
header: "**CyberAgent21卒内定者iOS輪読会** - iOSアプリ設計パターン入門"
footer: "by **＠ostk0069**"
theme: default
paginate: true
style: |
    section.title * , h1{
        text-align: center;
    }
---

# 第1回　CyberAgent21卒内定者iOS輪読会

---

# 今回は第一回です:clap:

---


今回の内容は
# 第一章 設計をすること (p15-21)
# 第二章 設計にパターンを適用する (p23-30)
についてです

---

# 第一章 設計をすること 

---
目次

## 1. 近年のiOS開発事情
## 2.「iOSアプリ」「設計」「パターン」
## 3. パターンを知るメリット
## 4. アーキテクチャも「パターン」

---

# 設計とはなんでしょうか。
# 設計はなぜ必要なのでしょうか。
#### ※一番最初に書いてあった文です


--- 

# :sweat:

--- 

## 1. 近年のiOS開発事情

---

## アプリでできることが増えた

- 端末のレイアウトの多様化
- safeareaの考え方の登場
- iPadの2分割画面
- 細かいユーザーインタラクション
    - 中断、復元可能なインタラクション 
- appClipやSiriKit,ARkitでのできることも増えた

---

## 頻繁・継続的なリリース

- リリースサイクルの短縮
    - 小幅な改修で不具合のリスクを減らす
    - QCのコストを減らす

---

## アプリの大規模化

- 画面数とユーザー数の増加
- コンポーネントの再利用の必要性
- ClashlyticsでのClashのログ収集

---

## プロジェクトの長期化

- 依存してるライブラリ、フレームワークの改修
- CoreData -> Realmの移行
- ObjC -> Swiftの移行
- Swift -> SwiftUIの移行(?)
- **環境の変化を織り込んだ構造を構築しないといけない**

---

## チーム開発での分業

- 多人数で開発することが増えた
    - 担当範囲が分けやすい状態を整備する
    - コンフリクトが起きないようにする
    - 影響範囲がわかりやすい状態にする

---

## 2.「iOSアプリ」「設計」「パターン」
- **関心の分類**
- モジュール分割
    - **問題を単純な問題の郡として切り分ける** => ソフトウェア設計の根幹の考え方

- 設計パターン
    - 再現性のある問題に対する共通の解決策
    - GoFデザインパターン(Singleton, Observerとか)
    - https://qiita.com/i-tanaka730/items/c63c6c22abd1477e0ba0
---

## 3. パターンを知るメリット
- 問題を定型化して捉えられる
    - 達人の生産性の鍵がGoFデザインパターンにある
    - 進研ゼミのやつ
- 解決策を客観的に比較できる
    - 複数パターンが適用できるとき先人は大体検討、解決策を提示済み
    - トレードオフがあってもそれを把握することで手戻りは少なくなる
- メンバーの共通言語となる
    - 複雑な設計は理解しづらい
    - パターンに名前があると認識がしやすい

---

## 4. アーキテクチャも「パターン」
- **一番優れたアーキテクチャは存在しない**
- ABテストをしたい、レスポンスハンドリングを重要視するニュースアプリ
- 大量の画面と状態管理を重要視するコミュニティアプリ
- キャラクラーの計算処理をするゲームアプリ
- 100人以上の開発者のいるプロジェクト
- 趣味開発の個人アプリ

---

> 私は「いつもこうする」と言うのを聞くと警戒心が湧く。私にとって設計に関する課題(と関心)の大半は、代替案をいくつか考えておくことであり、1つの代替案を採用することのトレードオフを判断することである。

Martin Fowler (エンタープライズアプリケーションアーキテクチャパターン)

---

(5分休憩してもいいすか)

---

# 第二章 設計にパターンを適用する

---

目次

## 1. 問題領域、責務、モジュール
## 2.アジャイル開発と設計の原則
## 3. パターンを使うのはいつか？
## 4. この章のまとめ

---

## 1. 問題領域、責務、モジュール
- 責務 - 解決すべき問題の領域
- モジュール - ひとまとまりの責務の置き場
- 責務分割が適切に行われた状態
    - 高凝集 - モジュール内で責務がまとまっている
    - 疎結合 - モジュール同士では責務が分かれてる
- 一度分離したはずの責務の境界が改修を繰り返すうちに曖昧になり破綻してしまうことはしばし起こります

---

## 切り分けられた責務の境界を守る

---

# Q. 昨日の日時を取得するextensionをはやす場所は？

---

## 1. Date型
## 2. Calendar型
## 3. 別の型

---

# Fat View Controllerができたとき...    
# 「まぁ、AppleがUIViewControllerなんていうViewだかControllerだか分からないような奴を用意したからね...」
# と思ったことありますか。僕はあります。

---

## UIViewControllerのドキュメントの定義
- データの変更に応じてViewsの内容を更新
- ユーザーインタラクションへの反応
- レイアウト管理
- 他のオブジェクトとの連携
https://developer.apple.com/documentation/uikit/uiviewcontroller

>  ViewControllerはViewからの入力を検証し、Data Objectに必要なフォーマットにパッケージすることもできます。しかし、実際のデータを管理する役割は最小限にしなければなりません。

---

## 責務を明確にイメージできる命名は重要
- ViewControllerはドキュメントがしっかりしてても
- HogeManagerはいいのか
- HogeServiceはいいのか
- HogeUtilはいいのか
-> 全て責務がイメージできずにFatになる危険性がある
- UtilがConverter,Validator,Formatter,Senderを兼任してたら分ける必要性が高そう
- これはクラスに限らずメソッドや変数でも同じことが言える

--- 

## 正しい名前に向き合う

---

記事詳細の画面でコメント一覧を取得する機能を作成するときに **ArticleUseCase** に **fetchComments()** があったので叩くことになった。仕様の追加でprefetchする必要性が出てきた。実装してリリースしたが、後ほど「まだ表示されていないコメントが既読になってしまう」という不具合を抱えてしまった。

果たして **fetchComments()** は正しい名前なのか。

--- 

Swiftコミュニティの「API Design Guideline」によると
メソッド、型、変数など、プログラムで使われる全てのインターフェイスが守るべき3つの原則は
- 1. 使い道を原則に
- 2. 短い名前よりも明確であることか重要
- 3. ドキュメントコメントを書く

今回の場合は **fetchCommentsAndMarkAllCommentsAsRead()** の方がいいのではないか

---

それでも長すぎる場合は以下のサインではないのか
- 設計を間違えているかもしれない
- 適切な粒度での抽象化ができていない

また以下の問題を抱えているのではないか
- 論理、設計の破綻
- 隠れている役割
- 所属のおかしさ

今回の場合は **fetchComments()** と **markAllCommentsAsRead()** に分けるのが良さそう

---

## 2.アジャイル開発と設計の原則
名前に向き合う覚悟ができてようやく設計の入り口

---

## アジャイル開発
- アジャイル = 「俊敏」
- アジャイルのサイクル
    1. アジャイルのプラクティスに従って問題を解決
    2. 設計の原則を適用して問題を分析
    3. 適切なパターンを適用して問題を解決

--- 

## 設計の原則とは

---

**SOLID原則**が代表例
- **硬さ**: 変更しにくいシステム。１つの変更によってシステムの他の部分に影響が及び、多くの変更を余儀なくさせるようなソフトウェア
- **もろさ**: 1つの変更によって、その変更とは概念的に関連のない箇所まで壊れてしまうようなソフトウェア
- **移植性のなさ**: 他のシステムでも再利用できる部分をモジュールとして切り離すことが困難なソフトウェア
- **扱いにくさ**: 正しいことをするよりも、誤ったことをする方が容易なソフトウェア
- **不必要な繰り返し**: 同じような構造を繰り返し含み、抽象化してまとめられる部分がまとまっていないソフトウェア
- **不必要な複雑さ**: 本質的な意味を持たない構造を内包してるようなソフトウェア
- **不透明さ**: 読みにくく、わかりにくい。その意図が伝わってこないソフトウェア

---

# SOLID原則はコードの臭さを取り除く物

---

## 原則を使うとき、使わないとき
- 過度に原則を使いすぎた設計は逆に「不必要な複雑さ」という臭いを放つ
https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
- アジャイル開発において **「迅速に完成させ」** **「変化に対応できること」** であり、その目的に反する場合はオーバーエンジニアリング
    - KISS(Keep it simple, small)
    - YAGNI(You are not going to need it)

---

## イテレーティブな設計に向けて
それはリファクタリング。

---

## リファクタリングは作り直しではない
- なんの保証もなく書き換えるのはただの破壊
- テストしやすさを前提に進める必要がある
- リファクタリングは少しずつ行うもの
- テストすることで早く作るためにも重要
    - テストの真の役割は実装を早くすることにある
    - **実装速度の向上に貢献しないテストには価値がない**

---

## チェッキングとテスティング
- チェッキング: QC(アプリを起動して確認する)
- テスティング: cmd + U

当たり前だけどテスティングの方がすぐに終わるよね
テストは不安要素に対して書くもので全てに書けばいいのではない

---

## テストのしやすさ
- 入力と出力が明確で、副作用がない
- 複雑な内部状態に依存しない
- 疎結合。処理に影響のあるオブジェクトは抽象的なインターフェイスとして表現されており、モックやタブに差し替え可能

ちなみに最小のテストは**型付け**

---

## 3. パターンを使うのはいつか？

---

Uncle Bobは言った

> リファクタリングをしながら、モジュール間の結びつきを弱めたり、シンプルにしたり、よりわかりやすく改善するその過程で、その**コードがある特定のデザインパターンに近づいている**ことに気がつくことがある。その時点で初めて、デザインパターンの名前に対応するようにクラス名や変数名を変え、また、パターンをより定型的な形式で使えるようにコードの構造を変えるようにする。

---

**コードがある特定のデザインパターンに近づいている**

-> **最初からパターンは存在せず、コードを修正して行く過程でその最終形にパターンを見出す**

---

Alexanderは言った

> 問題領域を理解したあと、おもむろにパターンを取り出して設計を始めるのではなく、問題領域を理解するためにパターンを使うということについて考察しているのです。

---

二人の共通点は単純な設計から始まり、少しずつパターンを見つけ、適用していくことにあるということ。パターンも設計もイテレーティブ(繰り返し)の中にある。

---

# 次回は 第三章 です
# 担当は　深見龍一[りゅういち, ジェダイ] です
# よろしくお願いしますー！